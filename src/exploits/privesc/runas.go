package privesc

import (
	"fmt"
	"log"
	"os/exec"
	"syscall"
	"unsafe"

	"golang.org/x/sys/windows"
)

// Load advapi32.dll and get the address of LogonUserW.
var (
	advapi32      = syscall.NewLazyDLL("advapi32.dll")
	procLogonUser = advapi32.NewProc("LogonUserW")
)

// These constants are used with LogonUser.
const (
	LOGON32_LOGON_NEW_CREDENTIALS = 9
	LOGON32_PROVIDER_DEFAULT      = 0
)

// Tokens is a simple type for managing tokens.
type Tokens struct {
	openHandles []windows.Handle
}

// New creates a new Tokens instance and enables required privileges.
func New() (*Tokens, error) {
	// Enable necessary privileges on the current process.
	if err := EnableRequiredPrivileges(); err != nil {
		return nil, fmt.Errorf("failed to enable required privileges: %v", err)
	}
	return &Tokens{}, nil
}

// Close cleans up any open handles.
func (t *Tokens) Close() {
	for _, h := range t.openHandles {
		windows.CloseHandle(h)
	}
	t.openHandles = nil
}

// EnableRequiredPrivileges enables SeAssignPrimaryTokenPrivilege and SeIncreaseQuotaPrivilege.
func EnableRequiredPrivileges() error {
	privileges := []string{"SeAssignPrimaryTokenPrivilege", "SeIncreaseQuotaPrivilege"}
	var token windows.Token
	err := windows.OpenProcessToken(windows.CurrentProcess(), windows.TOKEN_ADJUST_PRIVILEGES|windows.TOKEN_QUERY, &token)
	if err != nil {
		return fmt.Errorf("OpenProcessToken failed: %v", err)
	}
	defer token.Close()

	for _, priv := range privileges {
		var luid windows.LUID
		err := windows.LookupPrivilegeValue(nil, syscall.StringToUTF16Ptr(priv), &luid)
		if err != nil {
			return fmt.Errorf("LookupPrivilegeValue for %s failed: %v", priv, err)
		}

		tp := windows.Tokenprivileges{
			PrivilegeCount: 1,
			Privileges: [1]windows.LUIDAndAttributes{
				{Luid: luid, Attributes: windows.SE_PRIVILEGE_ENABLED},
			},
		}

		err = windows.AdjustTokenPrivileges(token, false, &tp, 0, nil, nil)
		if err != nil {
			return fmt.Errorf("AdjustTokenPrivileges for %s failed: %v", priv, err)
		}
	}
	return nil
}

// RunAs executes a command with specified credentials.
func (t *Tokens) RunAs(domain, username, password, command string) error {
	// Convert strings to UTF16 pointers.
	u, err := syscall.UTF16PtrFromString(username)
	if err != nil {
		return fmt.Errorf("failed to convert username: %v", err)
	}
	d, err := syscall.UTF16PtrFromString(domain)
	if err != nil {
		return fmt.Errorf("failed to convert domain: %v", err)
	}
	p, err := syscall.UTF16PtrFromString(password)
	if err != nil {
		return fmt.Errorf("failed to convert password: %v", err)
	}

	// Get user token using LogonUser.
	token, err := LogonUser(u, d, p, LOGON32_LOGON_NEW_CREDENTIALS, LOGON32_PROVIDER_DEFAULT)
	if err != nil {
		return fmt.Errorf("LogonUser failed: %v", err)
	}
	// We can close the token after duplicating.
	defer windows.CloseHandle(token)

	// Duplicate token for process creation.
	var duplicatedToken windows.Token
	err = windows.DuplicateTokenEx(
		windows.Token(token),
		windows.MAXIMUM_ALLOWED,
		nil,
		windows.SecurityImpersonation,
		windows.TokenPrimary,
		&duplicatedToken,
	)
	if err != nil {
		return fmt.Errorf("token duplication failed: %v", err)
	}
	defer duplicatedToken.Close()

	// Execute command with the duplicated token.
	cmd := exec.Command("C:\\Windows\\system32\\cmd.exe", "/C", command)
	cmd.SysProcAttr = &syscall.SysProcAttr{
		Token: syscall.Token(duplicatedToken),
	}

	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("command execution failed: %v\nOutput: %s", err, output)
	}

	log.Printf("Command output:\n%s", output)
	return nil
}

// LogonUser wraps the Windows LogonUserW API.
func LogonUser(username, domain, password *uint16, logonType, logonProvider uint32) (windows.Handle, error) {
	var token windows.Handle
	r1, _, err := procLogonUser.Call(
		uintptr(unsafe.Pointer(username)),
		uintptr(unsafe.Pointer(domain)),
		uintptr(unsafe.Pointer(password)),
		uintptr(logonType),
		uintptr(logonProvider),
		uintptr(unsafe.Pointer(&token)),
	)
	if r1 == 0 {
		return 0, err
	}
	return token, nil
}

