package privesc

import (
	"fmt"
	"golang.org/x/sys/windows"
	"syscall"
	"unsafe"
)

const (
	LOGON32_LOGON_NEW_CREDENTIALS = 9
	LOGON32_PROVIDER_DEFAULT      = 0
)

var (
	advapi32                 = syscall.NewLazyDLL("advapi32.dll")
	procLogonUserW           = advapi32.NewProc("LogonUserW")
	procImpersonateLoggedOnUser = advapi32.NewProc("ImpersonateLoggedOnUser")
	procRevertToSelf         = advapi32.NewProc("RevertToSelf")

	currentToken windows.Token
)

// MakeTokenTwo logs in and impersonates the given user
func MakeTokenTwo(domain, username, password string) (windows.Token, error) {
	domainPtr, _ := syscall.UTF16PtrFromString(domain)
	userPtr, _ := syscall.UTF16PtrFromString(username)
	passPtr, _ := syscall.UTF16PtrFromString(password)

	var tokenHandle windows.Handle

	ret, _, err := procLogonUserW.Call(
		uintptr(unsafe.Pointer(userPtr)),
		uintptr(unsafe.Pointer(domainPtr)),
		uintptr(unsafe.Pointer(passPtr)),
		uintptr(LOGON32_LOGON_NEW_CREDENTIALS),
		uintptr(LOGON32_PROVIDER_DEFAULT),
		uintptr(unsafe.Pointer(&tokenHandle)),
	)
	if ret == 0 {
		return 0, fmt.Errorf("LogonUserW failed: %v", err)
	}

	ret, _, err = procImpersonateLoggedOnUser.Call(uintptr(tokenHandle))
	if ret == 0 {
		windows.CloseHandle(tokenHandle)
		return 0, fmt.Errorf("Impersonation failed: %v", err)
	}

	return windows.Token(tokenHandle), nil
}

// RevertToken stops impersonation and closes the token handle
func RevertToken() error {
	if currentToken == 0 {
		return fmt.Errorf("no impersonated token to revert")
	}

	_, _, _ = procRevertToSelf.Call()
	_ = windows.CloseHandle(windows.Handle(currentToken))
	currentToken = 0
	return nil
}

